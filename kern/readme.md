## Excersise 1
### `boot_alloc()`
为n个字节分配内存

`nextfree`为空闲内存的下一个比特的虚拟地址
```c
static void *
boot_alloc(uint32_t n)
{
	static char *nextfree;	// virtual address of next byte of free memory
	char *result;

	// Initialize nextfree if this is the first time.
	// 'end' is a magic symbol automatically generated by the linker,
	// which points to the end of the kernel's bss segment:
	// the first virtual address that the linker did *not* assign
	// to any kernel code or global variables.
	if (!nextfree) {
		extern char end[];
		nextfree = ROUNDUP((char *) end, PGSIZE);
	}

	// Allocate a chunk large enough to hold 'n' bytes, then update
	// nextfree.  Make sure nextfree is kept aligned
	// to a multiple of PGSIZE.
	//
	// LAB 2: Your code here.
	result = nextfree;
	nextfree = ROUNDUP(nextfree+n, PGSIZE);
	if ((uint32_t) nextfree - KERNBASE > npages * PGSIZE) {
		panic("Out of memory!\n");
	}
	return result;
}
```
### `mem_init()`
首先为每个物理页面（一共`npages`个物理页面）的`PageInfo`分配内存。使用`pages`这个数组维护这些物理页面的`PageInfo`，并用`memset`初始化为0
```c
//////////////////////////////////////////////////////////////////////
	// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.
	// The kernel uses this array to keep track of physical pages: for
	// each physical page, there is a corresponding struct PageInfo in this
	// array.  'npages' is the number of physical pages in memory.  Use memset
	// to initialize all fields of each struct PageInfo to 0.
	// Your code goes here:
	pages = (struct PageInfo *) boot_alloc(npages * sizeof(struct PageInfo));
	memset(pages, 0, sizeof(pages));
```
然后使用子函数`page_init()`初始化pages数组，如果某页被占用，pp_ref置1，否则置0，并维护存储空闲物理页面的链表pgfree_list，可供后续分配的空闲物理页面包括：
- base memory中的[PGSIZE, npages_basemem * PGSIZE)
- [EXTPHYSMEM, ...)的部分页面
### `page_init()`
```c
void
page_init(void)
{
	// The example code here marks all physical pages as free.
	// However this is not truly the case.  What memory is free?
	//  1) Mark physical page 0 as in use.
	//     This way we preserve the real-mode IDT and BIOS structures
	//     in case we ever need them.  (Currently we don't, but...)
	//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)
	//     is free.
	//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must
	//     never be allocated.
	//  4) Then extended memory [EXTPHYSMEM, ...).
	//     Some of it is in use, some is free. Where is the kernel
	//     in physical memory?  Which pages are already in use for
	//     page tables and other data structures?
	//
	// Change the code to reflect this.
	// NB: DO NOT actually touch the physical memory corresponding to
	// free pages!
	size_t i;
	page_free_list = NULL;
	// The number of pages which has been allocated in the extended memory
	int num_alloc = ((uint32_t)boot_alloc(0) - KERNBASE) / PGSIZE;
	// The number of pages which has been allocated in the IO hole
	int num_iohole = KERNBASE / PGSIZE - npages_basemem;

	for (i = 0; i < npages; i++) {
		if (i == 0){
			pages[i].pp_ref = 1;
		}
		else if (i >= npages_basemem && i < npages_basemem + num_iohole + num_alloc){
			pages[i].pp_ref = 1;
		}
		else{
			pages[i].pp_ref = 0;
			pages[i].pp_link = page_free_list;
			page_free_list = &pages[i];
		}
	}
}
```
### `page_alloc()`
先判断保存空闲页面的`page_free_list`是否为空，若为空直接返回NULL。如果不为空，从其头部取出一个空闲页面，指针`free_page`指向这个页面，然后重置`page_free_list`，再把取出的`free_page`指向NULL，随后把这个空闲页面映射到对应的物理页面，用`memset`将这个物理页面初始化为0。
```c
// Allocates a physical page.  If (alloc_flags & ALLOC_ZERO), fills the entire
// returned physical page with '\0' bytes.  Does NOT increment the reference
// count of the page - the caller must do these if necessary (either explicitly
// or via page_insert).
//
// Be sure to set the pp_link field of the allocated page to NULL so
// page_free can check for double-free bugs.
//
// Returns NULL if out of free memory.
//
// Hint: use page2kva and memset
struct PageInfo *
page_alloc(int alloc_flags)
{
	// Fill this function in
	struct PageInfo *free_page;
	// If page_free_list is NULL
	if(!page_free_list){
		return NULL;
	}
	//
	free_page = page_free_list;
	page_free_list = free_page->pp_link;
	// Set the pp_link field of the allocated page to NULL
	free_page->pp_link = NULL;

	if (alloc_flags & ALLOC_ZERO){
		memset(page2kva(free_page), 0, PGSIZE);
	}
	return free_page;
}
```
### `page_free()`
回收页面`pp`，如果其`pp->ref`不为0或`pp->link`不为`NULL`，提出警告。
```c
void
page_free(struct PageInfo *pp)
{
	// Fill this function in
	// Hint: You may want to panic if pp->pp_ref is nonzero or
	// pp->pp_link is not NULL.
	if (pp->pp_ref != 0 || !pp->pp_link){
		panic("pp->pp_ref is nonzero or pp->pp_link is not NULL");
	}
	else{
		pp->pp_link = page_free_list;
		page_free_list = pp;
	}
}
```
## Excersise 4
### `pgdir_walk()`
给定指向页目录表的指针`pgdir`，返回线性地址`va`在页表中的地址。

1）求出`pd_entry_ptr`，其指向`va`所在的页表页在页目录表中的地址

2）判断这个页表项是否已经在内存中（通过PTE_P）

- 不在内存中
  	- `create` = false，返回`NULL`
  	- or `create` = true，在页目录中创建一个新的页表项，让`pd_entry_ptr`指向这个新的页表项
- 在内存中
	- 进行下一步

3）找到页表的基地址`page_base`

4）通过`PTE(va)`计算`va`的偏移`pt_offset`

5）在`page_base`的基础上加上这个偏移量，返回线性地址`va`在页表中的地址`&page_base[pt_offset]`
```c
// Given 'pgdir', a pointer to a page directory, pgdir_walk returns
// a pointer to the page table entry (PTE) for linear address 'va'.
// This requires walking the two-level page table structure.
//
// The relevant page table page might not exist yet.
// If this is true, and create == false, then pgdir_walk returns NULL.
// Otherwise, pgdir_walk allocates a new page table page with page_alloc.
//    - If the allocation fails, pgdir_walk returns NULL.
//    - Otherwise, the new page's reference count is incremented,
//	the page is cleared,
//	and pgdir_walk returns a pointer into the new page table page.
//
// Hint 1: you can turn a PageInfo * into the physical address of the
// page it refers to with page2pa() from kern/pmap.h.
//
// Hint 2: the x86 MMU checks permission bits in both the page directory
// and the page table, so it's safe to leave permissions in the page
// directory more permissive than strictly necessary.
//
// Hint 3: look at inc/mmu.h for useful macros that manipulate page
// table and page directory entries.
//
pte_t *
pgdir_walk(pde_t *pgdir, const void *va, int create)
{
	// Fill this function in
	unsigned int pd_offset = PDX(va);
	unsigned int pt_offset;
	pte_t *page_base = NULL;
	pde_t *pd_entry_ptr = pgdir + pd_offset;
	struct PageInfo *new_page = NULL;

	if(!(*pd_entry_ptr & PTE_P)){
		if(create){
			new_page = page_alloc(1);
			// The allocation fails, pgdir_walk returns NULL
			if(!new_page){
				return NULL;
			}
			// the new page's reference count is incremented
			new_page->pp_ref++;

			*pd_entry_ptr = (page2pa(new_page) | PTE_P | PTE_W | PTE_U);
		}
		else{
			// Create == false, pgdir_walk returns NULL
			return NULL;
		}
	}

	pt_offset = PTX(va);
	page_base = KADDR(PTE_ADDR(*pd_entry_ptr));

	return &page_base[pt_offset];
}
```
### `boot_map_region()`
使用for循环，每次循环将映射关系存放到页表项中。
```c
// Map [va, va+size) of virtual address space to physical [pa, pa+size)
// in the page table rooted at pgdir.  Size is a multiple of PGSIZE, and
// va and pa are both page-aligned.
// Use permission bits perm|PTE_P for the entries.
//
// This function is only intended to set up the ``static'' mappings
// above UTOP. As such, it should *not* change the pp_ref field on the
// mapped pages.
//
// Hint: the TA solution uses pgdir_walk
static void
boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)
{
	// Fill this function in
	int i;
	pte_t *entry = NULL;
	for (i=0; i<size; i+=PGSIZE){
		entry = pgdir_walk(pgdir, (void *)va, 1);
		*entry = (pa | perm | PTE_P);
		va += PGSIZE;
		pa += PGSIZE;
	}
}
```
### `page_lookup()`
1) 通过`pgdir_walk()`找到`va`对应的页表项地址`*entry`
- 如果页表项不存在或不存在于内存中，返回`NULL`
- 页表项存在，进行下一步

2) 用`pa2page()`找到`va`对应的物理页面`*va_page`

3) 如果`pte_store`非0，把该页表存放到`pte_store`中
```c
// Return the page mapped at virtual address 'va'.
// If pte_store is not zero, then we store in it the address
// of the pte for this page.  This is used by page_remove and
// can be used to verify page permissions for syscall arguments,
// but should not be used by most callers.
//
// Return NULL if there is no page mapped at va.
//
// Hint: the TA solution uses pgdir_walk and pa2page.
//
struct PageInfo *
page_lookup(pde_t *pgdir, void *va, pte_t **pte_store)
{
	// Fill this function in
	pte_t *entry = NULL;
	struct PageInfo *va_page = NULL;

	entry = pgdir_walk(pgdir, va, 0);
	if(!entry){
		return NULL;
	}
	if(!(*entry & PTE_P)){
		return NULL;
	}

	va_page = pa2page(PTE_ADDR(*entry));

	if(!pte_store){
		*pte_store = entry;
	}

	return va_page;
}
```
### `page_remove()`
去除`va`与对应物理页面之间的映射关系
```c
// Unmaps the physical page at virtual address 'va'.
// If there is no physical page at that address, silently does nothing.
//
// Details:
//   - The ref count on the physical page should decrement.
//   - The physical page should be freed if the refcount reaches 0.
//   - The pg table entry corresponding to 'va' should be set to 0.
//     (if such a PTE exists)
//   - The TLB must be invalidated if you remove an entry from
//     the page table.
//
// Hint: The TA solution is implemented using page_lookup,
// 	tlb_invalidate, and page_decref.
//
void
page_remove(pde_t *pgdir, void *va)
{
	// Fill this function in
	struct PageInfo *va_page;
	pte_t *entry = NULL;

	va_page = page_lookup(pgdir, va, &entry);
	if(!va_page) return;

	page_decref(va_page);
	tlb_invalidate(pgdir, va);
	*entry = 0;
}
```
### `page_insert()`
```c
// Map the physical page 'pp' at virtual address 'va'.
// The permissions (the low 12 bits) of the page table entry
// should be set to 'perm|PTE_P'.
//
// Requirements
//   - If there is already a page mapped at 'va', it should be page_remove()d.
//   - If necessary, on demand, a page table should be allocated and inserted
//     into 'pgdir'.
//   - pp->pp_ref should be incremented if the insertion succeeds.
//   - The TLB must be invalidated if a page was formerly present at 'va'.
//
// Corner-case hint: Make sure to consider what happens when the same
// pp is re-inserted at the same virtual address in the same pgdir.
// However, try not to distinguish this case in your code, as this
// frequently leads to subtle bugs; there's an elegant way to handle
// everything in one code path.
//
// RETURNS:
//   0 on success
//   -E_NO_MEM, if page table couldn't be allocated
//
// Hint: The TA solution is implemented using pgdir_walk, page_remove,
// and page2pa.
//
int
page_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm)
{
	// Fill this function in
	pte_t *entry = NULL;
	entry = pgdir_walk(pgdir, va, 1);
	if(!entry) return -E_NO_MEM;

	pp->pp_ref++;

	if((*entry) & PTE_P){
		page_remove(pgdir, va);
	}
	*entry = (page2pa(pp) | perm | PTE_P);

	pgdir[PDX(va)] |= perm;
	return 0;
}
```
## Excersise 5
### `mem_init()`
随后完善`mem_init()`，映射虚拟内存到对应的物理内存

1）映射`UPAGES`到`pages`数组，大小为一个`PTSIZE`

2）映射`[KSTACKTOP-KSTKSIZE, KSTACKTOP)`到`bootstack`变量所标记的物理地址区域

3）映射整个操作系统内核，虚拟内存`[KERNBASE, 2^32)`到物理内存 `[0, 2^32 - KERNBASE)`
```c
	//////////////////////////////////////////////////////////////////////
	// Now we set up virtual memory

	//////////////////////////////////////////////////////////////////////
	// Map 'pages' read-only by the user at linear address UPAGES
	// Permissions:
	//    - the new image at UPAGES -- kernel R, user R
	//      (ie. perm = PTE_U | PTE_P)
	//    - pages itself -- kernel RW, user NONE
	// Your code goes here:
	boot_map_region(kern_pgdir, UPAGES, PTSIZE, PADDR(pages), PTE_U);

	//////////////////////////////////////////////////////////////////////
	// Use the physical memory that 'bootstack' refers to as the kernel
	// stack.  The kernel stack grows down from virtual address KSTACKTOP.
	// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)
	// to be the kernel stack, but break this into two pieces:
	//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory
	//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if
	//       the kernel overflows its stack, it will fault rather than
	//       overwrite memory.  Known as a "guard page".
	//     Permissions: kernel RW, user NONE
	// Your code goes here:
	boot_map_region(kern_pgdir, KSTACKTOP-KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_W);

	//////////////////////////////////////////////////////////////////////
	// Map all of physical memory at KERNBASE.
	// Ie.  the VA range [KERNBASE, 2^32) should map to
	//      the PA range [0, 2^32 - KERNBASE)
	// We might not have 2^32 - KERNBASE bytes of physical memory, but
	// we just set up the mapping anyway.
	// Permissions: kernel RW, user NONE
	// Your code goes here:
	boot_map_region(kern_pgdir, KERNBASE, 0xffffffff-KERNBASE, 0, PTE_W);
```
# B. 问题回答
(1)
`boot/boot.S`中保护模式启动，第50行
```c
 orl     $CR0_PE_ON, %eax
```
(2)`kern_pgdir`的虚拟地址是？？？？，物理地址是？？？。在未完成本lab之前，使用的都是分段机制，利用段选择子到全局描述符表（GDT）中找到对应的段描述符，而这个段描述符中就存放着真正的段的物理首地址，然后再加上偏移地址量便得到了最后的物理地址，完成虚拟地址到物理地址的转换。

(3)
```c
lcr3(PADDR(kern_pgdir));
```
此时完成了虚拟内存到物理内存前256M的映射，并将`cr3`设置为`kern_pgdir`的物理地址

(4)
2GB。
JOS利用一个大小为4MB的空间`UPAGES`来存放所有的页的`PageInfo`结构体信息，每个结构体的大小为8B，故一共可以存放512K个`PageInfo`结构体，即可以出现512K个物理页，每个物理页大小为4KB，得出总的物理内存占2GB。

(5) 给定一个虚拟地址`va`，首先根据页目录基地址`pgdir`找到页目录在虚拟内存中的存放位置，随后在`pgdir`的基础上加上`PDX(va)`查找`va`在页目录中对应的页目录描述符，得到`va`对应的页表基地址，再在该页表上通过页表基地址加上`PTX(va)`查找`va`对应的页表项，最后在页表项对应的物理基地址`page_base`上加上页内偏移量得到最终的物理地址。

(6)
a) pgdir：指向页目录表的指针。虚拟地址。

b) pgtab：va所对应的页目录项的物理地址。物理地址。

c) pg：va所对应的页表项的物理地址。物理地址。

(7)
```c
Virtual memory map:                                Permissions
                                                    kernel/user

    4 Gig -------->  +------------------------------+
                     |                              | RW/--
                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                     :              .               :
                     :              .               :
                     :              .               :
                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| RW/--
                     |                              | RW/--
                     |   Remapped Physical Memory   | RW/--
                     |                              | RW/--
    KERNBASE, ---->  +------------------------------+ 0xf0000000      --+
    KSTACKTOP        |          bootstack           | RW/--  KSTKSIZE   |
                     | - - - - - - - - - - - - - - -| - - - - - - -  PTSIZE
                     |      Invalid Memory (*)      |                   |
                     :              .               :                   |
                     :              .               :                   |
    MMIOLIM ------>  +------------------------------+ 0xefc00000      --+
                     |                              | RW/--  PTSIZE
 ULIM, MMIOBASE -->  +------------------------------+ 0xef800000
                     |  Cur. Page Table (User R-)   | R-/R-  PTSIZE
    UVPT      ---->  +------------------------------+ 0xef400000
                     |          RO PAGES            | R-/R-  PTSIZE
    UPAGES    ---->  +------------------------------+ 0xef000000
                     |                              | R-/R-  PTSIZE
                     |                              |
                     |                              |
                     .                              .
                     .        Empty Memory (*)      .
                     .                              .
                     |                              |
                     |                              |
                     |                              |
    0 ------------>  +------------------------------+
```